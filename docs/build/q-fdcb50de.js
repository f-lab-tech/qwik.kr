import{i as e,u as a}from"./q-c0df5510.js";const s=[{text:"Caching Request and Response Pairs",id:"caching-request-and-response-pairs",level:1},{text:"Cache API",id:"cache-api",level:2},{text:"Dynamic Imports and Caching",id:"dynamic-imports-and-caching",level:2},{text:"Known Issues with link",id:"known-issues-with-link",level:2},{text:'link rel="modulepreload"',id:"link-relmodulepreload",level:3},{text:"Duplicate Requests",id:"duplicate-requests",level:3}],o={title:"Qwik City Caching Request and Response Pairs",meta:[],styles:[],links:[]},l={title:"Qwik City Caching Request and Response Pairs"};function t(i){const n=Object.assign({h1:"h1",a:"a",span:"span",p:"p",code:"code",h2:"h2",em:"em",pre:"pre",blockquote:"blockquote",h3:"h3",ul:"ul",li:"li"},i.components);return e(a,{children:[e(n.h1,{id:"caching-request-and-response-pairs",children:[e(n.a,{"aria-hidden":"true",tabIndex:"-1",href:"#caching-request-and-response-pairs",children:e(n.span,{className:"icon icon-link"})}),"Caching Request and Response Pairs"]}),`
`,e(n.p,{children:["In many traditional frameworks, the preferred strategy is to use ",e(n.code,{children:"<link>"})," with a ",e(n.code,{children:"rel"})," attribute of ",e(n.code,{children:"prefetch"}),", ",e(n.code,{children:"preload"})," or ",e(n.code,{children:"modulepreload"}),". However, there are ",e(n.a,{href:"#known-issues-with-link",children:"enough known issues"})," that Qwik has preferred to not make ",e(n.code,{children:"link"})," the default prefetching strategy (though it still can be ",e(n.a,{href:"/docs/advanced/prefetching/",children:"configured"}),")."]}),`
`,e(n.p,{children:["Instead, Qwik prefers to use a newer approach that takes full advantage of the browser's ",e(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Cache",children:"Cache API"}),", which is also better supported compared to ",e(n.a,{href:"#known-issues-with-link",children:"modulepreload"}),"."]}),`
`,e(n.h2,{id:"cache-api",children:[e(n.a,{"aria-hidden":"true",tabIndex:"-1",href:"#cache-api",children:e(n.span,{className:"icon icon-link"})}),"Cache API"]}),`
`,e(n.p,{children:["The ",e(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Cache",children:"Cache API"})," is often associated with service workers, as a way to store request and response pairs in order for an application to work offline. In addition to enabling applications to work without connectivity, the same Cache API provides an extremely powerful prefetching and caching mechanism available to Qwik."]}),`
`,e(n.p,{children:["Using the installed and activated ",e(n.a,{href:"/qwikcity/prefetching/service-worker-prefetching/",children:"service worker"})," to intercept requests, Qwik is able to handle specific requests for ",e(n.em,{children:"known"})," bundles. In contrast to the common way service workers are used, the default does not attempt to handle all requests, but rather, only known bundles generated by Qwik."]}),`
`,e(n.p,{children:["An advantage of Qwik's optimizer is it also generates a ",e(n.code,{children:"q-manifest.json"})," file. The manifest provides a detailed module graph of not only how bundles are associated, but also which symbols are within each bundle. This same module graph data is provided to the service worker which allows for every network request for known bundles to be handled by the cache."]}),`
`,e(n.h2,{id:"dynamic-imports-and-caching",children:[e(n.a,{"aria-hidden":"true",tabIndex:"-1",href:"#dynamic-imports-and-caching",children:e(n.span,{className:"icon icon-link"})}),"Dynamic Imports and Caching"]}),`
`,e(n.p,{children:["When Qwik requests a module it uses a dynamic ",e(n.code,{children:"import()"}),". For example, let's say a user interaction happened, requiring Qwik to execute a dynamic import for ",e(n.code,{children:"/build/q-abc.js"}),". The code to do so would look something like this:"]}),`
`,e(n.pre,{children:e(n.code,{className:"language-ts",children:[e(n.span,{className:"token keyword",children:"const"})," module ",e(n.span,{className:"token operator",children:"="})," ",e(n.span,{className:"token keyword",children:"await"})," ",e(n.span,{className:"token keyword",children:"import"}),e(n.span,{className:"token punctuation",children:"("}),e(n.span,{className:"token string",children:"'/build/q-abc.js'"}),e(n.span,{className:"token punctuation",children:")"}),e(n.span,{className:"token punctuation",children:";"}),`
`]})}),`
`,e(n.p,{children:[`What's important is here that Qwik itself has no knowledge of a prefetching or caching strategy. It's simply making a request for a URL. However, because we've installed a service worker, and the service worker is intercepting requests, it's able to inspect the URL and say, "look, this is a request for `,e(n.code,{children:"/build/q-abc.js"}),`! This is one of our bundles! Let's first check to see if we already have this in the cache before we do an actual network request."`]}),`
`,e(n.p,{children:"This is where the power of the service worker and cache API comes in! Qwik first pre-populates the cache for modules the user may soon request within another thread. And better yet, if it's already cached, then there's no need for the browser to do anything."}),`
`,e(n.p,{children:["Other benefits include ",e(n.a,{href:"/qwikcity/prefetching/parallelizing-network-requests/",children:"Parallelizing Network Requests"}),"."]}),`
`,e(n.h2,{id:"known-issues-with-link",children:[e(n.a,{"aria-hidden":"true",tabIndex:"-1",href:"#known-issues-with-link",children:e(n.span,{className:"icon icon-link"})}),"Known Issues with link"]}),`
`,e(n.p,{children:["The challenge with the link rel approach is the lack of support on ",e(n.em,{children:"all"})," devices, at least at the time of writing. Additionally, during development, it can be misleading that it works everywhere, while on mobile devices it is not easily visible that link prefetching is working correctly."]}),`
`,e(n.blockquote,{children:[`
`,e(n.p,{children:"Prefetch is a feature that's supposed to help make our visitor's experiences faster but with the wrong combination of browser and CDN / server it can make experiences slower!"}),`
`,e(n.p,{children:["- ",e("cite",{children:e("a",{href:"https://andydavies.me/blog/2020/07/08/rel-equals-prefetch-and-the-importance-of-effective-http-slash-2-prioritisation/",children:"Rel=prefetch and the Importance of Effective HTTP/2 Prioritisation"})})]}),`
`]}),`
`,e(n.h3,{id:"link-relmodulepreload",children:[e(n.a,{"aria-hidden":"true",tabIndex:"-1",href:"#link-relmodulepreload",children:e(n.span,{className:"icon icon-link"})}),'link rel="modulepreload"']}),`
`,e(n.ul,{children:[`
`,e(n.li,{children:["Even though it's in the HTML spec, that doesn't mean your end-users are preloading your app correctly. ",e(n.a,{href:"https://caniuse.com/link-rel-modulepreload",children:"Can I Use: modulepreload"})]}),`
`,e(n.li,{children:["Not supported by ",e(n.a,{href:"https://bugs.webkit.org/show_bug.cgi?id=180574",children:"Safari"}),". This means that for iPhone and iPad users (those who may benefit the most from prefetching), modules would not get prefetched."]}),`
`,e(n.li,{children:["Not supported by ",e(n.a,{href:"https://bugzilla.mozilla.org/show_bug.cgi?id=1425310",children:"Firefox"}),"."]}),`
`]}),`
`,e(n.h3,{id:"duplicate-requests",children:[e(n.a,{"aria-hidden":"true",tabIndex:"-1",href:"#duplicate-requests",children:e(n.span,{className:"icon icon-link"})}),"Duplicate Requests"]}),`
`,e(n.p,{children:["It may be possible to fire off duplicate requests for the same resource. For example, let's say we want to prefetch ",e(n.code,{children:"module-a.js"}),", and while that's being downloaded (which may take a short time or a very long time, we don't know), the user interacts with the app, which then decides to request and execute ",e(n.code,{children:"module-a.js"}),". At the time of writing, browsers will often fire off a second request, which makes matters worse."]}),`
`,e(n.p,{children:["The service worker approach can ",e(n.a,{href:"/qwikcity/prefetching/parallelizing-network-requests/",children:"avoid this"})," by identifying a request that is already in flight, waiting on the first request for ",e(n.code,{children:"module-a.js"})," to finish, and then cloning it for the second request. Meaning only one network request will happen, even though numerous modules and prefetches may call for the same request/response."]})]})}function c(i={}){const{wrapper:n}=i.components||{};return n?e(n,Object.assign({},i,{children:e(t,i)})):t(i)}export{c as default,l as frontmatter,o as head,s as headings};
