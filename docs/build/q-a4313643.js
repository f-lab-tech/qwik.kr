import{i as t,u as o}from"./q-c0df5510.js";const s={title:"Explicit Reactivity",meta:[],styles:[],links:[]},a={title:"Explicit Reactivity"};function c(n){const e=Object.assign({p:"p",code:"code"},n.components);return t(o,{children:[t(e.p,{children:["In addition to implicit reactivity created by the templates, Qwik supports explicit execution of code when a property changes. This is achieved through the ",t(e.code,{children:"useWatch$()"})," hook. ",t(e.code,{children:"useWatch$()"})," hooks execute before the component renders and can be asynchronous. The hook can also have a clean-up function that is invoked on the next hook execution or when the component is removed."]}),`
`,t(e.p,{children:["In this example clicking on ",t(e.code,{children:"+1"})," updates ",t(e.code,{children:"count"})," immediately. What we would like is to update the ",t(e.code,{children:"delay count"})," after a 2-second delay. If ",t(e.code,{children:"count"})," is updated before the 2 seconds are up then the timer is restarted."]}),`
`,t(e.p,{children:["Notice that ",t(e.code,{children:"useWatch$()"})," callback receives ",t(e.code,{children:"track"})," function. Use the ",t(e.code,{children:"track"})," function to tell Qwik which properties should trigger this watch. The ",t(e.code,{children:"track"})," function creates subscriptions in store. On each invocation of ",t(e.code,{children:"useWatch$()"})," the subscriptions are cleared, so it is important to always set up a new set of subscriptions. This is useful if the set of subscriptions changes during the function lifetime."]}),`
`,t(e.p,{children:["The ",t(e.code,{children:"useWatch$()"})," callback function can return a cleanup function. The clean-up function is invoked on the next ",t(e.code,{children:"useWatch$()"})," callback execution or when the component is removed. In our case, the cleanup function is used for returning code which clears the ",t(e.code,{children:"setTimeout"}),"."]}),`
`,t(e.p,{children:["The ",t(e.code,{children:"useWatch$()"})," callbacks execute before the component is rendered. This allows them to be used to compute values used in rendering. The function runs on both server and client. The server execution sets up subscriptions that are then serialized and available to the client. This saves the client from having to download all of the components and execute them at least once to recover the subscription information for the system."]})]})}function h(n={}){const{wrapper:e}=n.components||{};return e?t(e,Object.assign({},n,{children:t(c,n)})):c(n)}export{h as default,a as frontmatter,s as head};
