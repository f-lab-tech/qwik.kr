import{i as t,u as r}from"./q-c0df5510.js";const o=[{text:"Why is largeData serialized",id:"why-is-largedata-serialized",level:2}],s={title:"Understanding Qwik Difference - Capturing the lexical scope",meta:[],styles:[],links:[]},l={title:"Understanding Qwik Difference - Capturing the lexical scope"};function n(i){const e=Object.assign({p:"p",code:"code",ul:"ul",li:"li",h2:"h2",a:"a",span:"span"},i.components);return t(r,{children:[t(e.p,{children:["In this example, we will explore how Qwik serializes the component state. A naive approach would be for Qwik to simply save all of the state associated with the ",t(e.code,{children:"useStore()"}),". Qwik is more intelligent about the approach and tries to tree shake the stores that are not needed by the client."]}),`
`,t(e.p,{children:"The example consists of:"}),`
`,t(e.ul,{children:[`
`,t(e.li,{children:[t(e.code,{children:"<App/>"}),": which creates a store."]}),`
`,t(e.li,{children:["The Store contains the ",t(e.code,{children:"largeData"})," property. Assume that this is a large data set that is only needed on the server. An example of this is the HackerNews demo. The server must retrieve the news articles from the JSON API and then use that data to render them. The articles are read-only for the user and so the HTML response will never re-render on the client. For this reason, it would be preferable not to send the data to the client."]}),`
`,t(e.li,{children:"A button that updates unrelated data."}),`
`]}),`
`,t(e.p,{children:["Look into the HTML tab and notice that ",t(e.code,{children:"largeData"})," was serialized into ",t(e.code,{children:'<script type="qwik/json">'}),". This is not ideal because we are sending data to the client which will never change and will never be used for re-rendering. Your goal in this exercise is to fix this."]}),`
`,t(e.h2,{id:"why-is-largedata-serialized",children:[t(e.a,{"aria-hidden":"true",tabIndex:"-1",href:"#why-is-largedata-serialized",children:t(e.span,{className:"icon icon-link"})}),"Why is ",t(e.code,{children:"largeData"})," serialized"]}),`
`,t(e.p,{children:["Qwik's serialization process starts by using all of the listeners as serialization roots. In our case, the ",t(e.code,{children:"onClick$"})," on ",t(e.code,{children:"<button>"})," is used as a serialization root. Notice that the ",t(e.code,{children:"onClick$"})," closure closes over ",t(e.code,{children:"store"}),". The fact that ",t(e.code,{children:"onClick$"})," closes over ",t(e.code,{children:"store"})," gives Qwik no choice but to serialize the ",t(e.code,{children:"store"})," and, with it, all of the child properties."]}),`
`,t(e.p,{children:["To fix this, change the ",t(e.code,{children:"onClick$"})," closure from ",t(e.code,{children:"store.counter.count++"})," to ",t(e.code,{children:"counter.count++"}),". (We have already created a local reference for you for ",t(e.code,{children:"counter"}),".) This change modifies what the ",t(e.code,{children:"onClick$"})," closure captures. Capturing more specific references allows Qwik to remove the need to serialize the ",t(e.code,{children:"largeData"})," property."]}),`
`,t(e.p,{children:["Open the HTML tab and notice that Qwik no longer serializes ",t(e.code,{children:"largeData"})," in this example."]})]})}function c(i={}){const{wrapper:e}=i.components||{};return e?t(e,Object.assign({},i,{children:t(n,i)})):n(i)}export{c as default,l as frontmatter,s as head,o as headings};
